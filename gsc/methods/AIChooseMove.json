{"names":["AIChooseMove"],"callingMethods":[],"methodsCalled":["AddNTimes","FarCall","FarCall_hl","Predef","Random"],"methodAddressesUsed":["CheckEnemyLockedIn"],"varsSet":["wCurEnemyMove","wCurEnemyMoveNum"],"varsUsed":["wBattleMode","wEnemyDisabledMove","wInBattleTowerBattle","wLinkMode","wTrainerClass"],"varAddressesUsed":["AIScoringPointers","SmallFarFlagActionPredef","TrainerClassAttributes","wBuffer1","wEnemyMonMoves","wEnemyMonPP"],"constantsUsed":["CHECK_FLAG","NUM_MOVES","TRNATTR_AI_MOVE_WEIGHTS"],"lines":["AIChooseMove:","; Score each move in wEnemyMonMoves starting from wBuffer1. Lower is better.","; Pick the move with the lowest score.","","; Wildmons attack at random.","\tld a, [wBattleMode]","\tdec a","\tret z","","\tld a, [wLinkMode]","\tand a","\tret nz","","; No use picking a move if there\u0027s no choice.","\tfarcall CheckEnemyLockedIn","\tret nz","","; The default score is 20. Unusable moves are given a score of 80.","\tld a, 20","\tld hl, wBuffer1","\tld [hli], a","\tld [hli], a","\tld [hli], a","\tld [hl], a","","; Don\u0027t pick disabled moves.","\tld a, [wEnemyDisabledMove]","\tand a","\tjr z, .CheckPP","","\tld hl, wEnemyMonMoves","\tld c, 0",".CheckDisabledMove:","\tcp [hl]","\tjr z, .ScoreDisabledMove","\tinc c","\tinc hl","\tjr .CheckDisabledMove",".ScoreDisabledMove:","\tld hl, wBuffer1","\tld b, 0","\tadd hl, bc","\tld [hl], 80","","; Don\u0027t pick moves with 0 PP.",".CheckPP:","\tld hl, wBuffer1 - 1","\tld de, wEnemyMonPP","\tld b, 0",".CheckMovePP:","\tinc b","\tld a, b","\tcp NUM_MOVES + 1","\tjr z, .ApplyLayers","\tinc hl","\tld a, [de]","\tinc de","\tand PP_MASK","\tjr nz, .CheckMovePP","\tld [hl], 80","\tjr .CheckMovePP","","; Apply AI scoring layers depending on the trainer class.",".ApplyLayers:","\tld hl, TrainerClassAttributes + TRNATTR_AI_MOVE_WEIGHTS","","\t; If we have a battle in BattleTower just load the Attributes of the first trainer class in wTrainerClass (Falkner)","\t; so we have always the same AI, regardless of the loaded class of trainer","\tld a, [wInBattleTowerBattle]","\tbit 0, a","\tjr nz, .battle_tower_skip","","\tld a, [wTrainerClass]","\tdec a","\tld bc, 7 ; Trainer2AI - Trainer1AI","\tcall AddNTimes","",".battle_tower_skip","\tlb bc, CHECK_FLAG, 0","\tpush bc","\tpush hl","",".CheckLayer:","\tpop hl","\tpop bc","","\tld a, c","\tcp 16 ; up to 16 scoring layers","\tjr z, .DecrementScores","","\tpush bc","\tld d, BANK(TrainerClassAttributes)","\tpredef SmallFarFlagAction","\tld d, c","\tpop bc","","\tinc c","\tpush bc","\tpush hl","","\tld a, d","\tand a","\tjr z, .CheckLayer","","\tld hl, AIScoringPointers","\tdec c","\tld b, 0","\tadd hl, bc","\tadd hl, bc","\tld a, [hli]","\tld h, [hl]","\tld l, a","\tld a, BANK(AIScoring)","\tcall FarCall_hl","","\tjr .CheckLayer","","; Decrement the scores of all moves one by one until one reaches 0.",".DecrementScores:","\tld hl, wBuffer1","\tld de, wEnemyMonMoves","\tld c, NUM_MOVES","",".DecrementNextScore:","\t; If the enemy has no moves, this will infinite.","\tld a, [de]","\tinc de","\tand a","\tjr z, .DecrementScores","","\t; We are done whenever a score reaches 0","\tdec [hl]","\tjr z, .PickLowestScoreMoves","","\t; If we just decremented the fourth move\u0027s score, go back to the first move","\tinc hl","\tdec c","\tjr z, .DecrementScores","","\tjr .DecrementNextScore","","; In order to avoid bias towards the moves located first in memory, increment the scores","; that were decremented one more time than the rest (in case there was a tie).","; This means that the minimum score will be 1.",".PickLowestScoreMoves:","\tld a, c","",".move_loop","\tinc [hl]","\tdec hl","\tinc a","\tcp NUM_MOVES + 1","\tjr nz, .move_loop","","\tld hl, wBuffer1","\tld de, wEnemyMonMoves","\tld c, NUM_MOVES","","; Give a score of 0 to a blank move",".loop2","\tld a, [de]","\tand a","\tjr nz, .skip_load","\tld [hl], a","","; Disregard the move if its score is not 1",".skip_load","\tld a, [hl]","\tdec a","\tjr z, .keep","\txor a","\tld [hli], a","\tjr .after_toss","",".keep","\tld a, [de]","\tld [hli], a",".after_toss","\tinc de","\tdec c","\tjr nz, .loop2","","; Randomly choose one of the moves with a score of 1",".ChooseMove:","\tld hl, wBuffer1","\tcall Random","\tmaskbits NUM_MOVES","\tld c, a","\tld b, 0","\tadd hl, bc","\tld a, [hl]","\tand a","\tjr z, .ChooseMove","","\tld [wCurEnemyMove], a","\tld a, c","\tld [wCurEnemyMoveNum], a","\tret"],"name":"AIChooseMove","file":"engine/battle/ai/move.asm","lineNo":1,"address":147513,"addressUsedBy":["BattleTurn"]}