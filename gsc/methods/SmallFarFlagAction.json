{"names":["SmallFarFlagAction"],"callingMethods":[],"methodsCalled":["GetFarByte"],"methodAddressesUsed":[],"varsSet":[],"varsUsed":[],"varAddressesUsed":[],"constantsUsed":[],"lines":["SmallFarFlagAction:","; Perform action b on bit c in flag array hl.","; If checking a flag, check flag array d:hl unless d is 0.","","; For longer flag arrays, see FlagAction.","","\tpush hl","\tpush bc","","; Divide by 8 to get the byte we want.","\tpush bc","\tsrl c","\tsrl c","\tsrl c","\tld b, 0","\tadd hl, bc","\tpop bc","","; Which bit we want from the byte","\tld a, c","\tand 7","\tld c, a","","; Shift left until we can mask the bit","\tld a, 1","\tjr z, .shifted",".shift","\tadd a","\tdec c","\tjr nz, .shift",".shifted","\tld c, a","","; What are we doing to this flag?","\tdec b","\tjr z, .set ; 1 \u003d SET_FLAG","\tdec b","\tjr z, .check ; 2 \u003d CHECK_FLAG","; 0 \u003d RESET_FLAG","",".reset","\tld a, c","\tcpl","\tand [hl]","\tld [hl], a","\tjr .done","",".set","\tld a, [hl]","\tor c","\tld [hl], a","\tjr .done","",".check","\tld a, d","\tcp 0","\tjr nz, .farcheck","","\tld a, [hl]","\tand c","\tjr .done","",".farcheck","\tcall GetFarByte","\tand c","",".done","\tpop bc","\tpop hl","\tld c, a","\tret"],"name":"SmallFarFlagAction","file":"engine/smallflag.asm","lineNo":1,"address":156989,"addressUsedBy":[]}