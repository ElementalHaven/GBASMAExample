{"names":["ComputeMaxPP"],"callingMethods":["ApplyPPUp","GetMaxPPOfMove"],"methodsCalled":["Divide"],"methodAddressesUsed":[],"varsSet":["hDividend","hDivisor"],"varsUsed":["hQuotient","wTempPP"],"varAddressesUsed":[],"constantsUsed":[],"lines":["ComputeMaxPP:","\tpush bc","\t; Divide the base PP by 5.","\tld a, [de]","\tldh [hDividend + 3], a","\txor a","\tldh [hDividend], a","\tldh [hDividend + 1], a","\tldh [hDividend + 2], a","\tld a, 5","\tldh [hDivisor], a","\tld b, 4","\tcall Divide","\t; Get the number of PP, which are bits 6 and 7 of the PP value stored in RAM.","\tld a, [hl]","\tld b, a","\tswap a","\tand $f","\tsrl a","\tsrl a","\tld c, a","\t; If this value is 0, we are done","\tand a","\tjr z, .NoPPUp","",".loop","\t; Normally, a move with 40 PP would have 64 PP with three PP Ups.","\t; Since this would overflow into bit 6, we prevent that from happening","\t; by decreasing the extra amount of PP each PP Up provides, resulting","\t; in a maximum of 61.","\tldh a, [hQuotient + 3]","\tcp $8","\tjr c, .okay","\tld a, $7","",".okay","\tadd b","\tld b, a","\tld a, [wTempPP]","\tdec a","\tjr z, .NoPPUp","\tdec c","\tjr nz, .loop","",".NoPPUp:","\tld [hl], b","\tpop bc","\tret"],"name":"ComputeMaxPP","file":"engine/items/item_effects.asm","lineNo":2753,"address":81431,"addressUsedBy":[]}