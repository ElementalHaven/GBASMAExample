{"names":["_BattleRandom"],"callingMethods":[],"methodsCalled":["Random"],"methodAddressesUsed":[],"varsSet":["wLinkBattleRNCount"],"varsUsed":["wLinkBattleRNCount","wLinkMode"],"varAddressesUsed":["wLinkBattleRNs"],"constantsUsed":[],"lines":["_BattleRandom::","; If the normal RNG is used in a link battle it\u0027ll desync.","; To circumvent this a shared PRNG is used instead.","","; But if we\u0027re in a non-link battle we\u0027re safe to use it","\tld a, [wLinkMode]","\tand a","\tjp z, Random","","; The PRNG operates in streams of 10 values.","","; Which value are we trying to pull?","\tpush hl","\tpush bc","\tld a, [wLinkBattleRNCount]","\tld c, a","\tld b, 0","\tld hl, wLinkBattleRNs","\tadd hl, bc","\tinc a","\tld [wLinkBattleRNCount], a","","; If we haven\u0027t hit the end yet, we\u0027re good","\tcp 10 - 1 ; Exclude last value. See the closing comment","\tld a, [hl]","\tpop bc","\tpop hl","\tret c","","; If we have, we have to generate new pseudorandom data","; Instead of having multiple PRNGs, ten seeds are used","\tpush hl","\tpush bc","\tpush af","","; Reset count to 0","\txor a","\tld [wLinkBattleRNCount], a","\tld hl, wLinkBattleRNs","\tld b, 10 ; number of seeds","","; Generate next number in the sequence for each seed","; a[n+1] \u003d (a[n] * 5 + 1) % 256",".loop","\t; get last #","\tld a, [hl]","","\t; a * 5 + 1","\tld c, a","\tadd a","\tadd a","\tadd c","\tinc a","","\t; update #","\tld [hli], a","\tdec b","\tjr nz, .loop","","; This has the side effect of pulling the last value first,","; then wrapping around. As a result, when we check to see if","; we\u0027ve reached the end, we check the one before it.","","\tpop af","\tpop bc","\tpop hl","\tret"],"name":"_BattleRandom","file":"engine/battle/core.asm","lineNo":6876,"address":139646,"addressUsedBy":[]}