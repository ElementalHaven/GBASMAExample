{"names":["BattleCommand_Stab"],"callingMethods":["BattleCommand_Present"],"methodsCalled":["BattleCheckTypeMatchup","Divide","FarCall","GetBattleVar","GetBattleVarAddr","Multiply"],"methodAddressesUsed":["DoBadgeTypeBoosts","DoWeatherModifiers"],"varsSet":["hDivisor","hMultiplicand","hMultiplier","wAttackMissed","wCurDamage","wCurType","wTypeModifier"],"varsUsed":["hBattleTurn","hMultiplicand","hProduct","hQuotient","wCurType","wTypeMatchup","wTypeModifier"],"varAddressesUsed":["TypeMatchups","wBattleMonType1","wCurDamage","wEnemyMonType1","wTypeModifier"],"constantsUsed":["BATTLE_VARS_MOVE_ANIM","BATTLE_VARS_MOVE_TYPE","BATTLE_VARS_SUBSTATUS1_OPP"],"lines":["BattleCommand_Stab:","; STAB \u003d Same Type Attack Bonus","\tld a, BATTLE_VARS_MOVE_ANIM","\tcall GetBattleVar","\tcp STRUGGLE","\tret z","","\tld hl, wBattleMonType1","\tld a, [hli]","\tld b, a","\tld c, [hl]","\tld hl, wEnemyMonType1","\tld a, [hli]","\tld d, a","\tld e, [hl]","","\tldh a, [hBattleTurn]","\tand a","\tjr z, .go ; Who Attacks and who Defends","","\tld hl, wEnemyMonType1","\tld a, [hli]","\tld b, a","\tld c, [hl]","\tld hl, wBattleMonType1","\tld a, [hli]","\tld d, a","\tld e, [hl]","",".go","\tld a, BATTLE_VARS_MOVE_TYPE","\tcall GetBattleVarAddr","\tld [wCurType], a","","\tpush hl","\tpush de","\tpush bc","\tfarcall DoWeatherModifiers","\tpop bc","\tpop de","\tpop hl","","\tpush de","\tpush bc","\tfarcall DoBadgeTypeBoosts","\tpop bc","\tpop de","","\tld a, [wCurType]","\tcp b","\tjr z, .stab","\tcp c","\tjr z, .stab","","\tjr .SkipStab","",".stab","\tld hl, wCurDamage + 1","\tld a, [hld]","\tld h, [hl]","\tld l, a","","\tld b, h","\tld c, l","\tsrl b","\trr c","\tadd hl, bc","","\tld a, h","\tld [wCurDamage], a","\tld a, l","\tld [wCurDamage + 1], a","","\tld hl, wTypeModifier","\tset 7, [hl]","",".SkipStab:","\tld a, BATTLE_VARS_MOVE_TYPE","\tcall GetBattleVar","\tld b, a","\tld hl, TypeMatchups","",".TypesLoop:","\tld a, [hli]","","\tcp -1","\tjr z, .end","","\t; foresight","\tcp -2","\tjr nz, .SkipForesightCheck","\tld a, BATTLE_VARS_SUBSTATUS1_OPP","\tcall GetBattleVar","\tbit SUBSTATUS_IDENTIFIED, a","\tjr nz, .end","","\tjr .TypesLoop","",".SkipForesightCheck:","\tcp b","\tjr nz, .SkipType","\tld a, [hl]","\tcp d","\tjr z, .GotMatchup","\tcp e","\tjr z, .GotMatchup","\tjr .SkipType","",".GotMatchup:","\tpush hl","\tpush bc","\tinc hl","\tld a, [wTypeModifier]","\tand %10000000","\tld b, a","; If the target is immune to the move, treat it as a miss and calculate the damage as 0","\tld a, [hl]","\tand a","\tjr nz, .NotImmune","\tinc a","\tld [wAttackMissed], a","\txor a",".NotImmune:","\tldh [hMultiplier], a","\tadd b","\tld [wTypeModifier], a","","\txor a","\tldh [hMultiplicand + 0], a","","\tld hl, wCurDamage","\tld a, [hli]","\tldh [hMultiplicand + 1], a","\tld a, [hld]","\tldh [hMultiplicand + 2], a","","\tcall Multiply","","\tldh a, [hProduct + 1]","\tld b, a","\tldh a, [hProduct + 2]","\tor b","\tld b, a","\tldh a, [hProduct + 3]","\tor b","\tjr z, .ok ; This is a very convoluted way to get back that we\u0027ve essentially dealt no damage.","","; Take the product and divide it by 10.","\tld a, 10","\tldh [hDivisor], a","\tld b, 4","\tcall Divide","\tldh a, [hQuotient + 2]","\tld b, a","\tldh a, [hQuotient + 3]","\tor b","\tjr nz, .ok","","\tld a, 1","\tldh [hMultiplicand + 2], a","",".ok","\tldh a, [hMultiplicand + 1]","\tld [hli], a","\tldh a, [hMultiplicand + 2]","\tld [hl], a","\tpop bc","\tpop hl","",".SkipType:","\tinc hl","\tinc hl","\tjr .TypesLoop","",".end","\tcall BattleCheckTypeMatchup","\tld a, [wTypeMatchup]","\tld b, a","\tld a, [wTypeModifier]","\tand %10000000","\tor b","\tld [wTypeModifier], a","\tret"],"name":"BattleCommand_Stab","file":"engine/battle/effect_commands.asm","lineNo":1221,"address":117236,"addressUsedBy":["AI_Smart_PriorityHit","AIDamageCalc"]}