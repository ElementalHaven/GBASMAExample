{"names":["BattleCommand_CheckObedience"],"callingMethods":[],"methodsCalled":["BattlePartyAttr","BattleRandom","CheckUserIsCharging","DoMove","EndMoveEffect","HitConfusion","IgnoreSleepOnly","SetPlayerTurn","StdBattleTextbox","UpdateMoveData"],"methodAddressesUsed":[],"varsSet":["wAlreadyDisobeyed","wBattleMonStatus","wCurMoveNum","wCurPlayerMove","wLastPlayerCounterMove","wLastPlayerMove","wPlayerEncoreCount"],"varsUsed":["hBattleTurn","w2DMenuNumRows","wAlreadyDisobeyed","wBattleMonLevel","wBattleMonMoves","wCurMoveNum","wDisabledMove","wInBattleTowerBattle","wLinkMode","wPlayerID"],"varAddressesUsed":["BeganToNapText","IgnoredOrdersText","LoafingAroundText","TurnedAwayText","WontObeyText","wBattleMonMoves","wBattleMonPP","wJohtoBadges","wPlayerSubStatus5"],"constantsUsed":["MAX_LEVEL","MON_ID","NUM_MOVES"],"lines":["BattleCommand_CheckObedience:","; checkobedience","","\t; Enemy can\u0027t disobey","\tldh a, [hBattleTurn]","\tand a","\tret nz","","\tcall CheckUserIsCharging","\tret nz","","\t; If we\u0027ve already checked this turn","\tld a, [wAlreadyDisobeyed]","\tand a","\tret nz","","\txor a","\tld [wAlreadyDisobeyed], a","","\t; No obedience in link battles","\t; (since no handling exists for enemy)","\tld a, [wLinkMode]","\tand a","\tret nz","","\tld a, [wInBattleTowerBattle]","\tand a","\tret nz","","\t; If the monster\u0027s id doesn\u0027t match the player\u0027s,","\t; some conditions need to be met.","\tld a, MON_ID","\tcall BattlePartyAttr","","\tld a, [wPlayerID]","\tcp [hl]","\tjr nz, .obeylevel","\tinc hl","\tld a, [wPlayerID + 1]","\tcp [hl]","\tret z","",".obeylevel","\t; The maximum obedience level is constrained by owned badges:","\tld hl, wJohtoBadges","","\t; risingbadge","\tbit RISINGBADGE, [hl]","\tld a, MAX_LEVEL + 1","\tjr nz, .getlevel","","\t; stormbadge","\tbit STORMBADGE, [hl]","\tld a, 70","\tjr nz, .getlevel","","\t; fogbadge","\tbit FOGBADGE, [hl]","\tld a, 50","\tjr nz, .getlevel","","\t; hivebadge","\tbit HIVEBADGE, [hl]","\tld a, 30","\tjr nz, .getlevel","","\t; no badges","\tld a, 10","",".getlevel","; c \u003d obedience level","; d \u003d monster level","; b \u003d c + d","","\tld b, a","\tld c, a","","\tld a, [wBattleMonLevel]","\tld d, a","","\tadd b","\tld b, a","","; No overflow (this should never happen)","\tjr nc, .checklevel","\tld b, $ff","",".checklevel","; If the monster\u0027s level is lower than the obedience level, it will obey.","\tld a, c","\tcp d","\tret nc","","; Random number from 0 to obedience level + monster level",".rand1","\tcall BattleRandom","\tswap a","\tcp b","\tjr nc, .rand1","","; The higher above the obedience level the monster is,","; the more likely it is to disobey.","\tcp c","\tret c","","; Sleep-only moves have separate handling, and a higher chance of","; being ignored. Lazy monsters like their sleep.","\tcall IgnoreSleepOnly","\tret c","","; Another random number from 0 to obedience level + monster level",".rand2","\tcall BattleRandom","\tcp b","\tjr nc, .rand2","","; A second chance.","\tcp c","\tjr c, .UseInstead","","; No hope of using a move now.","","; b \u003d number of levels the monster is above the obedience level","\tld a, d","\tsub c","\tld b, a","","; The chance of napping is the difference out of 256.","\tcall BattleRandom","\tswap a","\tsub b","\tjr c, .Nap","","; The chance of not hitting itself is the same.","\tcp b","\tjr nc, .DoNothing","","\tld hl, WontObeyText","\tcall StdBattleTextbox","\tcall HitConfusion","\tjp .EndDisobedience","",".Nap:","\tcall BattleRandom","\tadd a","\tswap a","\tand SLP","\tjr z, .Nap","","\tld [wBattleMonStatus], a","","\tld hl, BeganToNapText","\tjr .Print","",".DoNothing:","\t; 4 random choices","\tcall BattleRandom","\tand %11","","\tld hl, LoafingAroundText","\tand a ; 0","\tjr z, .Print","","\tld hl, WontObeyText","\tdec a ; 1","\tjr z, .Print","","\tld hl, TurnedAwayText","\tdec a ; 2","\tjr z, .Print","","\tld hl, IgnoredOrdersText","",".Print:","\tcall StdBattleTextbox","\tjp .EndDisobedience","",".UseInstead:","; Can\u0027t use another move if the monster only has one!","\tld a, [wBattleMonMoves + 1]","\tand a","\tjr z, .DoNothing","","; Don\u0027t bother trying to handle Disable.","\tld a, [wDisabledMove]","\tand a","\tjr nz, .DoNothing","","\tld hl, wBattleMonPP","\tld de, wBattleMonMoves","\tld b, 0","\tld c, NUM_MOVES","",".GetTotalPP:","\tld a, [hli]","\tand PP_MASK","\tadd b","\tld b, a","","\tdec c","\tjr z, .CheckMovePP","","; Stop at undefined moves.","\tinc de","\tld a, [de]","\tand a","\tjr nz, .GetTotalPP","",".CheckMovePP:","\tld hl, wBattleMonPP","\tld a, [wCurMoveNum]","\tld e, a","\tld d, 0","\tadd hl, de","","; Can\u0027t use another move if only one move has PP.","\tld a, [hl]","\tand PP_MASK","\tcp b","\tjr z, .DoNothing","","; Make sure we can actually use the move once we get there.","\tld a, 1","\tld [wAlreadyDisobeyed], a","","\tld a, [w2DMenuNumRows]","\tld b, a","","; Save the move we originally picked for afterward.","\tld a, [wCurMoveNum]","\tld c, a","\tpush af","",".RandomMove:","\tcall BattleRandom","\tmaskbits NUM_MOVES","","\tcp b","\tjr nc, .RandomMove","","; Not the move we were trying to use.","\tcp c","\tjr z, .RandomMove","","; Make sure it has PP.","\tld [wCurMoveNum], a","\tld hl, wBattleMonPP","\tld e, a","\tld d, 0","\tadd hl, de","\tld a, [hl]","\tand PP_MASK","\tjr z, .RandomMove","","; Use it.","\tld a, [wCurMoveNum]","\tld c, a","\tld b, 0","\tld hl, wBattleMonMoves","\tadd hl, bc","\tld a, [hl]","\tld [wCurPlayerMove], a","","\tcall SetPlayerTurn","\tcall UpdateMoveData","\tcall DoMove","","; Restore original move choice.","\tpop af","\tld [wCurMoveNum], a","",".EndDisobedience:","\txor a","\tld [wLastPlayerMove], a","\tld [wLastPlayerCounterMove], a","","\t; Break Encore too.","\tld hl, wPlayerSubStatus5","\tres SUBSTATUS_ENCORED, [hl]","\txor a","\tld [wPlayerEncoreCount], a","","\tjp EndMoveEffect"],"name":"BattleCommand_CheckObedience","file":"engine/battle/effect_commands.asm","lineNo":633,"address":116825,"addressUsedBy":[]}